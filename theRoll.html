<!doctype html>
<html lang="en">
  <head>
    <base target="_top" />
    <meta charset="utf-8" \ />
    <meta name="appList" content="Boilerplate Function List" \ />
    <meta name="viewport" content="width=device-width, initial-scale=1" \ />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
      rel="stylesheet"
      \
    />
    <link
      href="https://fonts.googleapis.com/css?family=Acme"
      rel="stylesheet"
      \
    />
    <?!= builtStyling().evaluate().getContent() ?>
    <style>
      a:link,
      a:visited {
        color: black !important;
      }
      a:hover,
      a:active {
        color: white !important;
        text-decoration: none !important;
      }
    </style>
  </head>
  <body class="center container">
    <div class="row">
      <div
        class="center col s12 m12 l12 agenda z-depth-5 brown scale-out scale-in"
      >
        <div id="loadingIndicator" style="display: none">
          <nav
            class="agenda z-depth-5 pulse btn-large card-panel brown scale-out scale-in"
          >
            <a href="" target="_top" id="searchload">Loading...</a>
          </nav>
        </div>
        <br \ />
        <div
          class="center col s12 m12 l12"
          id="errorIndicator"
          style="display: none"
        >
          <nav
            class="agenda z-depth-5 pulse btn-large card-panel brown scale-out scale-in"
          >
            <a href="" target="_top" id="errorLoad"></a>
          </nav>
        </div>
        <br \ />
        <div class="center col s12 m12 l12" id="divLZ" style="display: block">
          <div
            class="center agenda col s4 l4 m4 push-s4 push-m4 push-l4 z-depth-5 brown scale-out scale-in pulse btn-large card-panel"
          >
            <input value="" class="timepicker" id="pRule" type="search" />
          </div>
        </div>
        <div id="folderSuggestions" class="autocomplete-suggestions"></div>
        <br \ /><br \ />
        <br \ />
        <div class="center col s12 m12 l12">
          <div
            class="center agenda col s2 m2 l2 push-s5 push-m5 push-l5 z-depth-5 brown scale-out scale-in pulse btn-large card-panel"
          >
            <button id="btn">Run It!</button>
          </div>
        </div>
      </div>
    </div>
    <div class="center col s12 m12 l12">
      <div id="pageBlock"></div>
    </div>
    <br \ />
    <div id="content" style="display: none">
      <div class="col s12 I12 m12 responsive-section brown">
        <div class="row container card-panel" style="clear: both">
          <iframe
            id="indexDrive"
            src=""
            style="border: none"
            width="100%"
            height="500vh"
            allow="autoplay"
            allow="encrypted-media"
            title="Dontime Life Website"
            frameborder="0"
            allowfullscreen
          ></iframe>
        </div>
      </div>
    </div>
  </body>
</html>
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    // Show the search area
    divLZ.style.display = "block";
  });
  function serverSide(func, args) {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler((result) => {
          resolve(result);
        })
        .withFailureHandler((error) => {
          console.log(error);
          reject(error);
        })
        .runBoilerplate(func, args);
    });
  }

  function debounce(func, delay) {
    let timeout = null;
    return function (...args) {
      const context = this;
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(context, args), delay);
    };
  }

  function setupAutocomplete(inputId, suggestionsDivId) {
    // Client-side code
    const localSuggestionsCache = {};
    const input = document.getElementById(inputId);
    const suggestionsDiv = document.getElementById(suggestionsDivId);

    if (!input || !suggestionsDiv) {
      console.error(
        "Input element " +
          inputId +
          " or suggestions div " +
          suggestionsDivId +
          " not found for autocomplete setup.",
      );
      return;
    }

    serverSide("getFolderValues", [])
      .then((response) => {
        // Rename 'fullList' to 'response' or 'payload' to avoid confusion
        // Access the actual array from the 'data' property
        let fullList = {};
        if (response && response.type === "object") {
          fullList = response.data;
        } else {
          console.warn(
            "Expected an object with an array in 'data' from chaseFunction, received:",
            response,
          );
          // Fallback to empty array if the structure is not as expected
          fullList = {};
        }
        localSuggestionsCache["Folders"] = fullList;
        console.log("Successfully fetched full list for Folders");
        console.log(
          "getFolderValues, [Folders]:" +
            JSON.stringify(
              localSuggestionsCache["Folders"].indexOf(event.target.value),
            ),
        );
      })
      .catch((error) => {
        console.error(
          "Error fetching address suggestions for " + inputId + ":",
          error,
        );
        suggestionsDiv.innerHTML = "<div>Error fetching suggestions.</div>";
      });

    const fetchSuggestions = debounce((query) => {
      if (query.length < 3) {
        suggestionsDiv.innerHTML = "";
        return;
      }

      // Filter the local list instead of making a server call
      const localList = localSuggestionsCache["Folders"] || [];
      console.log(
        "localSuggestionsCache[Folders] || [] ",
        localList.indexOf(query),
      );
      const suggestions = localList.filter((item) =>
        String(item).toLowerCase().includes(query.toLowerCase()),
      );

      suggestionsDiv.innerHTML = "";
      if (suggestions && suggestions.length > 0) {
        suggestions.forEach((suggestion) => {
          console.log(suggestion);
          const div = document.createElement("div");
          div.textContent = suggestion;
          div.addEventListener("click", () => {
            input.value = suggestion;
            suggestionsDiv.innerHTML = "";
          });
          suggestionsDiv.appendChild(div);
        });
      }
    }, 300);

    if (input && suggestionsDiv) {
      input.addEventListener("input", (event) => {
        fetchSuggestions(event.target.value);
      });

      document.addEventListener("click", (event) => {
        if (
          !input.contains(event.target) &&
          !suggestionsDiv.contains(event.target)
        ) {
          suggestionsDiv.innerHTML = "";
        }
      });

      input.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          suggestionsDiv.innerHTML = "";
          input.blur();
        }
      });
    } else {
      console.error(
        "Input element '" +
          inputId +
          "' or suggestions div '" +
          suggestionsDivId +
          "' not found for autocomplete setup.",
      );
    }
  }

  // Setup Autocomplete for Delivery Address
  setupAutocomplete("pRule", "folderSuggestions");
  var indexSc = document.getElementById("indexDrive");
  var displaySc = document.getElementById("pageBlock");
  var nameFile = document.getElementById("pRule");
  var runButton = document.getElementById("btn");
  nameFile.addEventListener("keypress", function (event) {
    // If the user preses the "Enter" key on the keyboard.
    if (event.key === "Enter") {
      // Hide the error reporting after filtering is complete;
      errorIndicator.style.display = "none";
      let compArr = nameFile.value.split(",");
      var folderComp = compArr[0];
      var search = compArr[1];
      // var search = nameFile.value;
      if (search) {
        // Show the loading indicator
        loadingIndicator.style.display = "block";
      }
      serverSide("fileBrowser", [folderComp, search])
        .then((filedMain) => {
          if (filedMain) {
            console.log("Error: server returning a", typeof filedMain);
            var fmRes = JSON.stringify(filedMain);
            console.log("Error: filedMain " + typeof filedMain + "," + fmRes);
            displaySc.innerHTML = "<p>" + JSON.parse(fmRes).name + "</p>";
            indexSc.src = JSON.parse(fmRes).url;
            // Hide the loading indicator after filtering is complete;
            loadingIndicator.style.display = "none";
            // Show the contentBox after filtering is complete;
            content.style.display = "block";
            // Hide the error reporting after filtering is complete;
            errorIndicator.style.display = "none";
          }
        })
        .catch((er) => {
          // Hide the loading indicator after error is returned
          loadingIndicator.style.display = "none";
          // Show the error indicator after error is returned
          errorIndicator.style.display = "block";
          if (er) {
            document.getElementById("errorLoad").innerHTML = er;
            alert(er);
          }
        });
    }
  });
  runButton.addEventListener("click", () => {
    // Hide the error reporting after filtering is complete;
    errorIndicator.style.display = "none";
    let compArr = nameFile.value.split(",");
    var folderComp = compArr[0];
    var search = compArr[1];
    // var search = nameFile.value;
    if (search) {
      // Show the loading indicator
      loadingIndicator.style.display = "block";
    }
    serverSide("fileBrowser", [folderComp, search])
      .then((filedMain) => {
        if (filedMain) {
          console.log("Error: server returning a", typeof filedMain);
          var fmRes = JSON.stringify(filedMain);
          console.log("Error: filedMain " + typeof filedMain + "," + fmRes);
          displaySc.innerHTML = "<p>" + JSON.parse(fmRes).name + "</p>";
          indexSc.src = JSON.parse(fmRes).url;
          // Hide the loading indicator after filtering is complete;
          loadingIndicator.style.display = "none";
          // Show the contentBox after filtering is complete;
          content.style.display = "block";
          // Hide the error reporting after filtering is complete;
          errorIndicator.style.display = "none";
        }
      })
      .catch((er) => {
        // Hide the loading indicator after error is returned
        loadingIndicator.style.display = "none";
        // Show the error indicator after error is returned
        errorIndicator.style.display = "block";
        if (er) {
          document.getElementById("errorLoad").innerHTML = er;
          alert(er);
        }
      });
  });
</script>
